VERSION=3.pre48
## Makefile for CCCC - a C and C++ Code Counter
##
## derived from an original makefile generated by the pccts genmk utility
##
## As of version 2.1.5 this makefile is called cccc.mak
## some lesser used facilities have also been cleared out, including some
## of the targets I used to use for specific debugging tasks, and
## the DJGPP compilation configuration, which has gone on the basis that
## the MSVC and Cygnus configurations are more useful for Win32 users.

## This makefile has profited from significant contributions from 
## Herman H"uni, who provided a configuration for Solaris, and also from 
## Thomas Hieber who has done a lot of work on porting to various Win32 
## configurations.

# The interface between the parsers and the internal database has been 
# reworked considerably.  The C++ and Java parsers have been upgraded to the
# new interface, but this work has not yet been done on the Ada parser, hence
# it is for the time being disabled.  
INCLUDE_CC=true
INCLUDE_JAVA=true
INCLUDE_ADA=false

# A flag to allow debugging to be turned off when the project approaches
# production standard.
ifneq "$(DEBUG)" "false"
DEBUG=true
endif

## Up to 3pre6, this makefile needed to know where PCCTS was.
## I've now decided to package the PCCTS source as part of the 
## distribution, so this becomes a bit easier
PCCTS=../pccts
PCCTS_H=$(PCCTS)/h
PCCTS_BIN=$(PCCTS)/bin


# There are less configurations than there used to be, but hopefully
# they cover as many combinations of platform and compiler system.

ifneq "$(COMSPEC)" ""
# Win32 platform, Visual C++ compile system
# (probably need 5.0 or better for a good enough STL)
# NB this doesn't appear to be visible on my NT workstation, so
# I have modified the .dsp file to pass CONF= on the gmake command line.
CONF=w32vc
endif

ifeq "$(OSTYPE)" "OSF"
# Compaq/Digital OSF/Unix/Tru64 with native C++ compiler cxx
CONF=osf
endif

ifeq "$(OSTYPE)" "SOLARIS"
# Herman Hu"ni contributed a makefile patch for Solaris
# It depended on the availability of g++, so _should_ be 
# equivalent to the gnu configuration below.
# I would be interested in having a patch to include a configuration
# based on the native Solaris C++ compiler if anyone can
# contribute one
CONF=gnu
endif

ifeq "$(CONF)" ""

# I would be interested in receiving patches with configurations of the 
# variables described under the CONF="" section below for
# other platforms including using the native compilers on various
# Unix variants (the gnu variant should do for g++ based builds anywhere)
# and other operating systems (VMS, MACOS etc).

# The gnu configuration will work on Linux, but should be equally 
# appropriate on other Unix variants, and possibly with the Cygnus
# g++ as well.  g++ version must be at least 2.8 or egcs 1.0.1.

# Where a variant is defined above but a good enough version of g++ is 
# available, this option can be used by overriding CONF on the make 
# command line.
CONF=gnu
endif


## the sections below configure the make for the various machines
## which I do builds on
##
## each stanza is gated on a value of the variable CONF
## note that the sections mix freely differences due to the nature of
## the operating system and differences due to the configuration of the
## particular machine in use
## 
## the first stanza (which is selected if the CONF variable is empty)
## contains a template of all of the definitions which will be required

ifeq "$(CONF)" ""

## compiler to use and associated flags 
CCC =            ## C++ compiler
LD =             ## linker
CFLAGS =         ## compiler flags
LDFLAGS =        ## linker flags
CPPEXT =         ## the extension on C++ files generate by PCCTS
OBJEXT =         ## the extension for object files 
COPY =           ## the operating system command for copying a file
RM =             ## the operating system command for removing files
CCCC_BIN =       ## the name of the cccc binary

endif

ifeq "$(CONF)" "gnu"

## it would be nice to compile with all warnings turn on, but there are so
## many warnings associated with unused variables, parameters and labels that
## it is impossible to see anything happening
#GCC_WARNINGS = -Wreturn-type -Wparentheses -Wswitch -Wcomment
GCC_WARNINGS = -Wall -Wno-unused -Wno-uninitialized 


## using the GNU C++ compiler
## we need working templates to a standard which supports the STL
## I use egcs v1.0.1, gcc v2.7 is not likely to be OK,
## gcc v2.8 should be

# support for debugging (note that debug building is on by default)
ifeq "$(DEBUG)" "true"
CFLAGS_DEBUG=-g
LDFLAGS_DEBUG=-g
endif

CCC=g++
LD=g++ 
CFLAGS = $(CFLAGS_DEBUG) $(GCC_WARNINGS) -I/usr/include/g++-include -I. -I$(PCCTS_H)
LDFLAGS = $(LDFLAGS_DEBUG) -static -o $(CCCC_BIN)
CPPEXT=cpp
OBJEXT=o
COPY=cp
RM=rm
CCCC_BIN=cccc

endif

# Win32 + MS Visual C++ (v5 or v6)
ifeq "$(CONF)" "w32vc"

## the GNU make command under DOS appears to be much more sensitive
## to white space than under Unix
## There should be no white space anywhere on any of the lines in this
## section (i.e. neither at the start, middle nor end of line)

# support for debugging (note that debug building is on by default)
ifeq "$(DEBUG)" "true"
CFLAGS_DEBUG=-Zi
LDFLAGS_DEBUG=-Zi
endif

CCC=cl.exe -nologo
LD=cl.exe -nologo
CFLAGS=-I$(PCCTS_H) $(CFLAGS_DEBUG) -GX -TP -DCCCC_CONF_W32VC
LDFLAGS=$(LDFLAGS_DEBUG) -Fe$(CCCC_BIN)
CPPEXT=cpp
OBJEXT=obj
COPY=copy
RM=del
CCCC_BIN=cccc.exe

endif

# Win32 + Borland C++ 
ifeq "$(CONF)" "w32bc"

# I have two versions of the Borland C++ compiler available.
# One is part of C++ Builder 3, the other is from the free 
# command line tools set they issued recently.
#BCPATH=C:/Progra~1/Borland/CBuilder3
BCPATH=C:/Borland/Bcc55

## the GNU make command under DOS appears to be much more sensitive
## to white space than under Unix
## There should be no white space anywhere on any of the lines in this
## section (i.e. neither at the start, middle nor end of line)

# support for debugging (note that debug building is on by default)
ifeq "$(DEBUG)" "true"
CFLAGS_DEBUG= -w -y -v -vi
LDFLAGS_DEBUG= 
endif
PATH=$(BCPATH)/bin
LIB=$(BCPATH)/lib
CCC=$(BCPATH)/bin/bcc32.exe 
LD=$(BCPATH)/bin/bcc32.exe $(CFLAGS_DEBUG) -L$(BCPATH)/lib
CFLAGS=-I$(PCCTS_H) $(CFLAGS_DEBUG) -I$(BCPATH)/include -w-aus -P -DCCCC_CONF_W32BC
LDFLAGS=$(LDFLAGS_DEBUG) 
CPPEXT=cpp
OBJEXT=obj
COPY=copy
RM=del
CCCC_BIN=cccc.exe

endif


ifeq "$(CONF)" "osf"

CCC=cxx -x cxx -define_templates
LD=cxx -o cccc
CFLAGS =        -g -I. -I$(PCCTS_H) -DOSF_TEMPLATES -DEXPAND_TEMPLATES -nocleanup
LDFLAGS =       -g 
CPPEXT=cpp
OBJEXT=o
COPY=cp
RM=rm
CCCC_BIN=cccc

endif

## locations and flags for antlr and dlg (don't change the flags unless you 
## understand PCCTS)
ANTLR =         $(PCCTS_BIN)/antlr
DLG =           $(PCCTS_BIN)/dlg
# Flags for ANTLR:
# -CC       = generate C++ output
# -k 2      = use at least 2 tokens of lookahead
# -gd       = generate rule tracing code (calls to tracein() and traceout())
# -ge       = generate token classes to represent the initial set for 
#             each rule (called error sets, because their main use is
#             in simplifying error reporting when a rule fails).
# -rl 5000  = a limit on the size of the internal analysis network
#             used by the parser generator
# -w1       = basic error reporting
# The -gl flag is an option.  This causes ANTLR to emit #line directives
# which allow the compiler to generate line numbers relating to 
# positions in the .g file instead of the generated cpp files.  
# These can be useful to an IDE (jumping to error lines, e.g. in 
# emacs), or in the debugger.  
# At one time this option was broken to the extent that the code emitted 
# was actually illegal under some circumstances, but it is better now.  
# The problem is that there are still a lot of lines in the generated 
# source which do not correspond with lines in the .g file.  On balance,
# if I am debugging it is better to leave -gl off, while for onward
# development it is better to turn it on and enable the IDE features.
AFLAGS =        -CC -k 2 -gd -ge -rl 5000 -w1 -e3 
#AFLAGS =        -CC -k 2 -gd -ge -rl 5000 -w1 -e3

# Flags for DLG
DFLAGS =        -C2 -CC 


## list of files generated by the PCCTS utilities
CCCC_SPAWN =    cccc.$(CPPEXT) CParser.$(CPPEXT) CParser.h \
		Ctokens.h CLexer.$(CPPEXT) CLexer.h
JAVA_SPAWN =    java.$(CPPEXT) JParser.$(CPPEXT) JParser.h \
		Jtokens.h JLexer.$(CPPEXT) JLexer.h
ADA_SPAWN =     ada.$(CPPEXT) AdaPrser.$(CPPEXT) AdaPrser.h \
		Atokens.h ALexer.$(CPPEXT) ALexer.h

## the source files of the project itself
USR_G =         cccc.g java.g ada.g

USR_C =         ccccmain.cc cccc_tok.cc cccc_met.cc cccc_utl.cc \
		cccc_db.cc cccc_rec.cc cccc_ext.cc cccc_prj.cc cccc_mod.cc \
		cccc_mem.cc cccc_use.cc cccc_htm.cc cccc_tbl.cc cccc_tpl.cc \
		cccc_new.cc cccc_itm.cc cccc_opt.cc

USR_H =         cccc.h cccc_tok.h cccc_met.h cccc_utl.h \
			cccc_db.h cccc_htm.h cccc_tbl.h cccc_itm.h \
			cccc_opt.h

## documentation 
USR_DOC =       readme.txt cccc_ug.htm

## all source files
USR_SOURCE =    makefile cccc.mak cccc.dsw \
	$(USR_G) $(USR_H) $(USR_C) $(USR_DAT) $(USR_DOC)

## the final executable is linked from 3 groups of object files:

# object files compiled from PCCTS support code which does not change
PCCTS_OBJ =     AParser.$(OBJEXT) DLexerBase.$(OBJEXT) ATokenBuffer.$(OBJEXT) 

# object files compiled from C++ files generated by anltr and dlg
# They are now separated so that each language can be included or
# excluded by using make variables defined above.
ifeq "$(INCLUDE_CC)" "true"
CCCC_SPAWN_OBJ=cccc.$(OBJEXT) CLexer.$(OBJEXT) CParser.$(OBJEXT) 
CC_LANG_DEFINE=-DCC_INCLUDED
endif

ifeq "$(INCLUDE_JAVA)" "true"
JAVA_SPAWN_OBJ=java.$(OBJEXT) JLexer.$(OBJEXT) JParser.$(OBJEXT) 
JAVA_LANG_DEFINE=-DJAVA_INCLUDED
endif

ifeq "$(INCLUDE_ADA)" "true"
ADA_SPAWN_OBJ=ada.$(OBJEXT)  ALexer.$(OBJEXT) AdaPrser.$(OBJEXT)
ADA_LANG_DEFINE=-DADA_INCLUDED
endif

SPAWN_OBJ = $(CCCC_SPAWN_OBJ) $(JAVA_SPAWN_OBJ) $(ADA_SPAWN_OBJ)
LANG_DEFINES = $(CC_LANG_DEFINE) $(JAVA_LANG_DEFINE) $(ADA_LANG_DEFINE)

# object files compiled from .cc files which are part of the cccc source
USR_OBJ = \
	ccccmain.$(OBJEXT) cccc_utl.$(OBJEXT) cccc_opt.$(OBJEXT) \
	cccc_db.$(OBJEXT)  cccc_rec.$(OBJEXT) cccc_ext.$(OBJEXT) \
	cccc_prj.$(OBJEXT) cccc_mod.$(OBJEXT) cccc_mem.$(OBJEXT) \
	cccc_use.$(OBJEXT) cccc_met.$(OBJEXT) cccc_htm.$(OBJEXT) \
	cccc_tok.$(OBJEXT) cccc_tbl.$(OBJEXT) \
	cccc_tpl.$(OBJEXT) cccc_new.$(OBJEXT) cccc_itm.$(OBJEXT) \


ALL_OBJ = $(SPAWN_OBJ) $(USR_OBJ) $(PCCTS_OBJ) 

VPATH = $(PCCTS_H)


all: $(CCCC_BIN) 


$(CCCC_BIN): $(USR_G) $(ANLTR_SPAWN) $(DLG_SPAWN) $(USR_H) $(USR_C) $(ALL_OBJ)
	$(LD) $(ALL_OBJ) $(LD_EXTRA_LIBS) $(LDFLAGS) 

.SUFFIXES: .cc .$(OBJEXT) .cpp .cxx .g .g_info

## ANTLR can give us some very useful documentation including a 
## cross reference of the rules and a list of first token sets
## for each rule

.g.g_info:
	$(ANTLR) $(AFLAGS) -gc -gx -pa $< > $*.1st
	$(ANTLR) $(AFLAGS) -gc -gx -cr $< > $*.xrf

## a special rule to make the version number appear
ifneq "$(VERSION)" ""
ccccmain.$(OBJEXT) : ccccmain.cc 
	$(CCC) -c $(CFLAGS) $(LANG_DEFINES) -DCCCC_VERSION=\"$(VERSION)\" ccccmain.cc
else
ccccmain.$(OBJEXT) : ccccmain.cc 
	$(CCC) -c $(CFLAGS) $(LANG_DEFINES) ccccmain.cc
endif


.cc.$(OBJEXT):
	$(CCC) -c $(CFLAGS) $<

.cpp.$(OBJEXT):
	$(CCC) -c $(CFLAGS) $<

.cxx.$(OBJEXT):
	$(CCC) -c $(CFLAGS) $<


$(CCCC_SPAWN) : cccc.g
	$(ANTLR) $(AFLAGS) -ft Ctokens.h cccc.g
	$(DLG) $(DFLAGS) -cl CLexer parser.dlg

$(JAVA_SPAWN) : java.g
	$(ANTLR) $(AFLAGS) -ft Jtokens.h java.g
	$(DLG) $(DFLAGS) -cl JLexer parser.dlg

## -ci argument to DLG is because unlike C/C++/Java, Ada is defined as being
## case insensitive
## NB CCCC does not map case: if the code processed is not consistent in
## capitalisation of the name of a package, the reports will treat it as 
## two different packages
$(ADA_SPAWN) : ada.g
	$(ANTLR) $(AFLAGS) -ft Atokens.h ada.g
	$(DLG) $(DFLAGS) -ci -cl ALexer parser.dlg

# touch enables us to mark everything up to date to avoid enormous 
# recompilations (particularly after checking everything in and out of RCS)

touch:
	touch cccc.g
	touch *.cpp
	touch *.cxx
	touch *.cc
	touch *.h
	touch *.$(OBJEXT)
	touch cccc

clean:
	-$(RM) *.$(OBJEXT)
	-$(RM) $(CCCC_BIN)


## the linking rules include the undefined variable $(LD_EXTRA_LIBS)
## this allows us to include any arbitrary extra libraries in the link
## overriding the default implementations of library functions
## one area where this is useful is in linking with special debugging
## versions of the malloc library

## Electric Fence by Bruce Perens, 
## available from ftp:://sunsite.unc.edu/pub/Linux/devel/lang/c/
cccc.ef : cccc
	-mv -f cccc cccc.old
	make LD_EXTRA_LIBS=-lefence
	-mv -f cccc cccc.ef
	-mv cccc.old cccc

## Dmalloc by Gray Watson, available from ftp://ftp.letters.com/src/dmalloc
cccc.dm :
	-mv -f cccc cccc.old
	make LD_EXTRA_LIBS=-ldmalloc
	-mv -f cccc cccc.dm
	-mv cccc.old cccc

## GNU malloc
## (I don't think this is any different from the malloc in Linux libc.a)
cccc.gm :
	-mv -f cccc cccc.old
	make LD_EXTRA_LIBS=/usr/local/lib/libmalloc.a
	-mv -f cccc cccc.gm
	-mv cccc.old cccc












